/* *  Copyright (c) 2022 Contributors to the Eclipse Foundation *   All rights reserved. This program and the accompanying materials *   are made available under the terms of the Eclipse Public License v1.0 *   and Apache License v2.0 which accompanies this distribution. *   The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html *   and the Apache License v2.0 is available at http://www.opensource.org/licenses/apache2.0.php. * *   You may elect to redistribute this code under either of these licenses. * *   Contributors: * *   Otavio Santana */package org.eclipse.jnosql.mapping.core.repository;import jakarta.data.exceptions.NonUniqueResultException;import jakarta.data.page.Page;import jakarta.data.page.PageRequest;import jakarta.data.repository.CrudRepository;import org.eclipse.jnosql.mapping.DynamicQueryException;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;import java.lang.reflect.Method;import java.math.BigDecimal;import java.util.Collection;import java.util.Deque;import java.util.List;import java.util.NavigableSet;import java.util.Optional;import java.util.Queue;import java.util.Set;import java.util.SortedSet;import java.util.function.Function;import java.util.function.Supplier;import java.util.stream.Stream;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;class DynamicReturnTest {    private static final Function<String, String> SORT_MAPPER = Function.identity();    @Test    void shouldReturnNPEWhenThereIsPagination() {        Method method = getMethod(PersonRepository.class, "getOptional");        Supplier<Stream<?>> stream = Stream::empty;        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        assertThrows(NullPointerException.class, () ->                DynamicReturn.builder()                        .classSource(Person.class)                        .methodSource(method).result(stream)                        .singleResult(singleResult)                        .pagination(PageRequest.ofPage(1L).size(2)).build());    }    @Test    void shouldReturnEmptyOptional() {        Method method = getMethod(PersonRepository.class, "getOptional");        Supplier<Stream<?>> stream = Stream::empty;        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Optional);        Optional<Person> optional = (Optional) execute;        Assertions.assertFalse(optional.isPresent());    }    @Test    void shouldReturnOptional() {        Method method = getMethod(PersonRepository.class, "getOptional");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Optional);        Optional<Person> optional = (Optional) execute;        assertTrue(optional.isPresent());        Assertions.assertEquals(new Person("Ada"), optional.get());    }    @Test    void shouldReturnOptionalError() {        Method method = getMethod(PersonRepository.class, "getOptional");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Poliana"), new Person("Otavio"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        assertThrows(NonUniqueResultException.class, dynamicReturn::execute);    }    @Test    void shouldReturnAnInstance() {        Method method = getMethod(PersonRepository.class, "getInstance");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Person);        Person person = (Person) execute;        Assertions.assertEquals(new Person("Ada"), person);    }    @Test    void shouldReturnNull() {        Method method = getMethod(PersonRepository.class, "getInstance");        Supplier<Stream<?>> stream = Stream::empty;        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertNull(execute);    }    @Test    void shouldReturnList() {        Method method = getMethod(PersonRepository.class, "getList");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof List);        List<Person> persons = (List) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.getFirst());    }    @Test    void shouldReturnIterable() {        Method method = getMethod(PersonRepository.class, "getIterable");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Iterable);        Iterable<Person> persons = (List) execute;        Assertions.assertEquals(new Person("Ada"), persons.iterator().next());    }    @Test    void shouldReturnCollection() {        Method method = getMethod(PersonRepository.class, "getCollection");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Collection);        Collection<Person> persons = (Collection) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.iterator().next());    }    @Test    void shouldReturnSet() {        Method method = getMethod(PersonRepository.class, "getSet");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Set);        Set<Person> persons = (Set) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.iterator().next());    }    @Test    void shouldReturnQueue() {        Method method = getMethod(PersonRepository.class, "getQueue");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Queue);        Queue<Person> persons = (Queue) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.iterator().next());    }    @Test    void shouldReturnStream() {        Method method = getMethod(PersonRepository.class, "getStream");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Stream);        Stream<Person> persons = (Stream) execute;        Assertions.assertEquals(new Person("Ada"), persons.iterator().next());    }    @Test    void shouldReturnSortedSet() {        Method method = getMethod(PersonRepository.class, "getSortedSet");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof SortedSet);        SortedSet<Person> persons = (SortedSet) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.getFirst());    }    @Test    void shouldReturnNavigableSet() {        Method method = getMethod(PersonRepository.class, "getNavigableSet");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof NavigableSet);        NavigableSet<Person> persons = (NavigableSet) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.getFirst());    }    @Test    void shouldReturnDeque() {        Method method = getMethod(PersonRepository.class, "getDeque");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        Object execute = dynamicReturn.execute();        assertTrue(execute instanceof Deque);        Deque<Person> persons = (Deque) execute;        Assertions.assertFalse(persons.isEmpty());        Assertions.assertEquals(new Person("Ada"), persons.getFirst());    }    @Test    void shouldReturnErrorWhenExecutePage() {        Method method = getMethod(PersonRepository.class, "getPage");        Supplier<Stream<?>> stream = () -> Stream.of(new Person("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Person.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        assertThrows(DynamicQueryException.class, dynamicReturn::execute);    }    @Test    void shouldReturnErrorNavigableSetEntityIsNotComparable() {        Method method = getMethod(AnimalRepository.class, "getSortedSet");        Supplier<Stream<?>> stream = () -> Stream.of(new Animal("Ada"));        Supplier<Optional<?>> singleResult = DynamicReturn.toSingleResult(method).apply(stream);        DynamicReturn<?> dynamicReturn = DynamicReturn.builder()                .classSource(Animal.class)                .methodSource(method).result(stream)                .singleResult(singleResult).build();        assertThrows(DynamicQueryException.class, dynamicReturn::execute);    }    @Test    void shouldReturnNullWhenParamIsEmptyOnFindSpecial() {        assertTrue(DynamicReturn.findSpecialParameters(null, SORT_MAPPER).isEmpty());        assertTrue(DynamicReturn.findSpecialParameters(new Object[0], SORT_MAPPER).isEmpty());    }    @Test    void shouldFindSpecial() {        PageRequest pageRequest = PageRequest.ofPage(1L).size(2);        SpecialParameters specialParameters = DynamicReturn.findSpecialParameters(new Object[]{"value", 23, pageRequest}, SORT_MAPPER);        Assertions.assertEquals(pageRequest, specialParameters.pageRequest().orElseThrow());    }    @Test    void shouldReturnNullWhenThereIsNotSpecial() {        SpecialParameters pagination = DynamicReturn.findSpecialParameters(new Object[]{"value", 23, BigDecimal.TEN}, SORT_MAPPER);        assertTrue(pagination.isEmpty());    }    @Test    void shouldReturnNullWhenParamIsEmptyOnFindPagination() {        assertNull(DynamicReturn.findPageRequest(null));        assertNull(DynamicReturn.findPageRequest(new Object[0]));    }    @Test    void shouldFindPagination() {        PageRequest pageRequest = PageRequest.ofPage(1L).size(2);        PageRequest pageRequest2 = DynamicReturn.findPageRequest(new Object[]{"value", 23, pageRequest});        Assertions.assertEquals(pageRequest, pageRequest2);    }    @Test    void shouldReturnNullWhenThereIsNotPagination() {        PageRequest pageRequest = DynamicReturn.findPageRequest(new Object[]{"value", 23, BigDecimal.TEN});        assertNull(pageRequest);    }    private Method getMethod(Class<?> repository, String methodName) {        return Stream.of(repository.getDeclaredMethods())                .filter(m -> m.getName().equals(methodName))                .findFirst().get();    }    private record Animal(String name) {    }    private record Person(String name) implements Comparable<Person> {        @Override        public int compareTo(Person o) {            return name.compareTo(o.name);        }    }    private interface AnimalRepository extends CrudRepository<Animal, String> {        SortedSet<Person> getSortedSet();    }    private interface PersonRepository extends CrudRepository<Person, String> {        Optional<Person> getOptional();        Person getInstance();        List<Person> getList();        Iterable<Person> getIterable();        Collection<Person> getCollection();        Set<Person> getSet();        Queue<Person> getQueue();        Stream<Person> getStream();        SortedSet<Person> getSortedSet();        NavigableSet<Person> getNavigableSet();        Deque<Person> getDeque();        Page<Person> getPage();    }}