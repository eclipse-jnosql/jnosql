= Eclipse JNoSQL
:toc: auto

== Introduction

Eclipse JNoSQL is a compatible implementation of the https://jakarta.ee/specifications/nosql/[Jakarta NoSQL] and https://jakarta.ee/specifications/data/[Jakarta Data] specifications, a Java framework that streamlines the integration of Java applications with NoSQL databases.

== Goals

* Increase productivity performing common NoSQL operations
* Rich Object Mapping integrated with Contexts and Dependency Injection (CDI)
* Java-based Query and Fluent-API
* Persistence lifecycle events
* Low-level mapping using Standard NoSQL APIs
* Specific template API to each NoSQL category
* Annotation-oriented using JPA-like naming when it makes sense
* Extensible to explore the particular behavior of a NoSQL database
* Explore the popularity of Apache TinkerPop in Graph API
* Jakarta NoSQL and Data implementations

== One Mapping API to Multiples NoSQL Databases

Eclipse JNoSQL provides one API for each NoSQL database type. However, it incorporates the same annotations from the https://jakarta.ee/specifications/persistence/[Jakarta Persistence] specification and heritage Java Persistence API (JPA) to map Java objects. Therefore, with just these annotations that look like JPA, there is support for more than twenty NoSQL databases.

[source,java]
----
@Entity
public class Car {

    @Id
    private Long id;
    @Column
    private String name;
    @Column
    private CarType type;
 //...
}
----

Theses annotations from the Mapping API will look familiar to the Jakarta Persistence/JPA developer:

[cols="Annotation description"]
|===
|Annotation|Description

|`@jakarta.nosql.Entity`
|Specifies that the class is an entity. This annotation is applied to the entity class.

|`@jakarta.nosql.Id`
|Specifies the primary key of an entity.

|`@jakarta.nosql.Column`
|Specify the mapped column for a persistent property or field.

|`@org.eclipse.jnosql.mapping.Embeddable`
|Specifies a class whose instances are stored as an intrinsic part of an owning entity and share the entity's identity.

|`@org.eclipse.jnosql.mapping.Convert`
|Specifies the conversion of a Basic field or property.

|`@org.eclipse.jnosql.mapping.MappedSuperclass`
|Designates a class whose mapping information is applied to the entities that inherit from it. A mapped superclass has no separate table defined for it.

|`@org.eclipse.jnosql.mapping.Inheritance`
|Specifies the inheritance strategy to be used for an entity class hierarchy.

|`@org.eclipse.jnosql.mapping.DiscriminatorColumn`
|Specifies the discriminator column for the mapping strategy.

|`@org.eclipse.jnosql.mapping.DiscriminatorValue`
|Specifies the value of the discriminator column for entities of the given type.


|===

IMPORTANT: Although similar to JPA, Jakarta NoSQL defines persistable fields with either the ```@Id``` or ```@Column``` annotation.

After mapping an entity, you can explore the advantage of using a ```Template``` interface, which can increase productivity on NoSQL operations.

[source,java]
----
@Inject
Template template;
...

Car ferrari = Car.id(1L)
        .name("Ferrari")
        .type(CarType.SPORT);

template.insert(ferrari);
Optional<Car> car = template.find(Car.class, 1L);
template.delete(Car.class, 1L);

List<Car> cars = template.select(Car.class).where("name").eq("Ferrari").result();
template.delete(Car.class).execute();
----

This template has specialization to take advantage of a particular NoSQL database type.

A ``Repository`` interface is also provided for exploring the Domain-Driven Design (DDD) pattern for a higher abstraction.

[source,java]
----
public interface CarRepository extends PageableRepository<Car, String> {

    Optional<Car> findByName(String name);

}

@Inject
CarRepository repository;
...

Car ferrari = Car.id(1L)
        .name("Ferrari")
        .type(CarType.SPORT);

repository.save(ferrari);
Optional<Car> idResult = repository.findById(1L);
Optional<Car> nameResult = repository.findByName("Ferrari");
----


== Getting Started

Eclipse JNoSQL requires these minimum requirements:

* Java 11 (or higher)
* https://jakarta.ee/specifications/cdi/3.0/[Jakarta Contexts & Dependency Injection 3.0] (CDI)
* https://jakarta.ee/specifications/jsonb/2.0/[Jakarta JSON Binding 2.0] (JSON-B)
* https://jakarta.ee/specifications/jsonp/2.2/[Jakarta JSON Processing 2.0] (JSON-P)
* https://microprofile.io/microprofile-config/[MicroProfile Config]

=== NoSQL Database Types

Eclipse JNoSQL provides common annotations and interfaces. Thus, the same annotations and interfaces, ```Template``` and ```Repository```, will work on the four NoSQL database types.

Jakarta NoSQL also provides particular behavior to each database type. Currently, there is support for four NoSQL database types:

* Key-Value
* Column Family
* Document
* Graph

=== Key-Value

Jakarta NoSQL provides a Key-Value template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>jnosql-mapping-key-value</artifactId>
    <version>1.0.0-b5</version>
</dependency>
----

Furthermore, check for a Key-Value communications driver. You can find some implementations in the JNoSQL https://github.com/eclipse/jnosql-communication-driver[Communications Driver API].

[source,java]
----
@Inject
KeyValueTemplate template;
...

Car ferrari = Car.id(1L).name("ferrari").city("Rome").type(CarType.SPORT);

template.put(ferrari);
Optional<Car> car = template.get(1L, Car.class);
template.delete(1L);
----

Key-Value is database agnostic. Thus, you can change the database in your application with no or minimal impact on source code.

You can define the database settings using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification, so you can add properties and overwrite it in the environment following the https://12factor.net/config[Twelve-Factor App].

[source,properties]
----
jnosql.keyvalue.database=<DATABASE>
jnosql.keyvalue.provider=<CLASS-DRIVER>
jnosql.provider.host=<HOST>
jnosql.provider.user=<USER>
jnosql.provider.password=<PASSWORD>
----

TIP: The ```jnosql.keyvalue.provider``` property is necessary when you have more than one driver in the classpath. Otherwise, it will take the first one.

These configuration settings are the default behavior. Nevertheless, there is an option to programmatically configure these settings. Create a class that implements the ```Supplier<BucketManager>``` interface and then define it using the ```@Alternative``` and ```@Priority``` annotations.

[source,java]
----
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
@ApplicationScoped
public class ManagerSupplier implements Supplier<BucketManager> {

    @Produces
    public BucketManager get() {
        Settings settings = Settings.builder()
                .put("credential", "value")
                .build();
        KeyValueConfiguration configuration = new NoSQLKeyValueProvider();
        BucketManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

You can work with several Key-Value database instances through the CDI qualifier. To identify each database instance, make a ```BucketManager``` visible for CDI by adding the ```@Produces``` and the ```@Database``` annotations in the method.

[source,java]
----
@Inject
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseA")
private KeyValueTemplate templateA;

@Inject
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseB")
private KeyValueTemplate templateB;

// producers methods
@Produces
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseA")
public BucketManager getManagerA() {
    BucketManager manager = // instance;
    return manager;
}

@Produces
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseB")
public BucketManager getManagerB() {
    BucketManager manager = // instance;
    return manager;
}
----

=== Column Family

Jakarta NoSQL provides a Column Family template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>jnosql-mapping-column</artifactId>
    <version>1.0.0-b5</version>
</dependency>
----

Furthermore, check for a Column Family communications driver. You can find some implementations in the JNoSQL https://github.com/eclipse/jnosql-communication-driver[Communications Driver API].

[source,java]
----
@Inject
ColumnTemplate template;
...

Car ferrari = Car.id(1L)
        .name("ferrari").city("Rome")
        .type(CarType.SPORT);

template.insert(ferrari);
Optional<Car> car = template.find(Car.class, 1L);

template.delete(Car.class).where("id").eq(1L).execute();

Optional<Car> result = template.singleResult("select * from Car where _id = 1");
----

Column Family is database agnostic. Thus, you can change the database in your application with no or minimal impact on source code.

You can define the database settings using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification, so you can add properties and overwrite it in the environment following the https://12factor.net/config[Twelve-Factor App].

[source,properties]
----
jnosql.column.database=<DATABASE>
jnosql.column.provider=<CLASS-DRIVER>
jnosql.provider.host=<HOST>
jnosql.provider.user=<USER>
jnosql.provider.password=<PASSWORD>
----

TIP: The ```jnosql.column.provider``` property is necessary when you have more than one driver in the classpath. Otherwise, it will take the first one.

These configuration settings are the default behavior. Nevertheless, there is an option to programmatically configure these settings. Create a class that implements the ```Supplier<ColumnManager>``` interface, then define it using the ```@Alternative``` and ```@Priority``` annotations.

[source,java]
----
@Alternative
@Priority(Interceptor.Priority.APPLICrATION)
@ApplicationScoped
public class ManagerSupplier implements Supplier<ColumnManager> {

    @Produces
    public ColumnManager get() {
        Settings settings = Settings.builder()
                .put("credential", "value")
                .build();
        ColumnConfiguration configuration = new NoSQLColumnProvider();
        ColumnManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

You can work with several column database instances through CDI qualifier. To identify each database instance, make a ``ColumnManager`` visible for CDI by putting the ```@Produces``` and the ```@Database``` annotations in the method.

[source,java]
----
@Inject
@Database(value = DatabaseType.COLUMN, provider = "databaseA")
private ColumnTemplate templateA;

@Inject
@Database(value = DatabaseType.COLUMN, provider = "databaseB")
private ColumnTemplate templateB;

// producers methods
@Produces
@Database(value = DatabaseType.COLUMN, provider = "databaseA")
public ColumnManager getManagerA() {
    return manager;
}

@Produces
@Database(value = DatabaseType.COLUMN, provider = "databaseB")
public ColumnManager getManagerB() {
    return manager;
}
----

=== Document

Jakarta NoSQL provides a Document template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>jnosql-mapping-document</artifactId>
    <version>1.0.0-b5</version>
</dependency>
----

Furthermore, check for a Document communications driver. You can find some implementations in the JNoSQL https://github.com/eclipse/jnosql-communication-driver[Communications Driver API].

[source,java]
----
@Inject
DocumentTemplate template;
...

Car ferrari = Car.id(1L)
        .name("ferrari")
        .city("Rome")
        .type(CarType.SPORT);

template.insert(ferrari);
Optional<Car> car = template.find(Car.class, 1L);

template.delete(Car.class).where("id").eq(1L).execute();

Optional<Car> result = template.singleResult("select * from Car where _id = 1");
----

Document is database agnostic. Thus, you can change the database in your application with no or minimal impact on source code.

You can define the database settings using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification, so you can add properties and overwrite it in the environment following the https://12factor.net/config[Twelve-Factor App].

[source,properties]
----
jnosql.document.database=<DATABASE>
jnosql.document.provider=<CLASS-DRIVER>
jnosql.provider.host=<HOST>
jnosql.provider.user=<USER>
jnosql.provider.password=<PASSWORD>
----

TIP: The ```jnosql.document.provider``` property is necessary when you have more than one driver in the classpath. Otherwise, it will take the first one.

These configuration settings are the default behavior. Nevertheless, there is an option to programmatically configure these settings. Create a class that implements the ```Supplier<DocumentManager>```, then define it using the ```@Alternative``` and ```@Priority``` annotations.

[source,java]
----
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
@ApplicationScoped
public class ManagerSupplier implements Supplier<DocumentManager> {

    @Produces
    public DocumentManager get() {
        Settings settings = Settings.builder()
                .put("credential", "value")
                .build();
        DocumentConfiguration configuration = new NoSQLDocumentProvider();
        DocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

You can work with several document database instances through CDI qualifier. To identify each database instance, make a ```DocumentManager``` visible for CDI by putting the ```@Produces``` and the ```@Database``` annotations in the method.

[source,java]
----
@Inject
@Database(value = DatabaseType.DOCUMENT, provider = "databaseA")
private DocumentTemplate templateA;

@Inject
@Database(value = DatabaseType.DOCUMENT, provider = "databaseB")
private DocumentTemplate templateB;

// producers methods
@Produces
@Database(value = DatabaseType.DOCUMENT, provider = "databaseA")
public DocumentManager getManagerA() {
    return manager;
}

@Produces
@Database(value = DatabaseType.DOCUMENT, provider = "databaseB")
public DocumentManager getManagerB() {
    return manager;
}
----

=== Graph

Jakarta NoSQL provides a Graph template to explore the specific behavior of this NoSQL type.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>jnosql-mapping-graph</artifactId>
    <version>1.0.0-b5</version>
</dependency>
----

Despite the other three Jakarta NoSQL types, Graph does *not* provide a communication layer from Jakarta NoSQL API. Instead, it integrates with https://tinkerpop.apache.org/[Apache Tinkerpop 3.x].

[source,java]
----
@Inject
GraphTemplate template;
...

Category java = Category.of("Java");
Book effectiveJava = Book.of("Effective Java");

template.insert(java);
template.insert(effectiveJava);
EdgeEntity edge = template.edge(java, "is", software);

Stream<Book> books = template.getTraversalVertex()
        .hasLabel("Category")
        .has("name", "Java")
        .in("is")
        .hasLabel("Book")
        .getResult();
----

Apache TinkerPop is database agnostic. Thus, you can change the database in your application with no or minimal impact on source code.

You can define the database settings using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification, so you can add properties and overwrite it in the environment following the https://12factor.net/config[Twelve-Factor App].

[source,properties]
----
jnosql.graph.provider=<CLASS-DRIVER>
jnosql.provider.host=<HOST>
jnosql.provider.user=<USER>
jnosql.provider.password=<PASSWORD>
----

TIP: The ```jnosql.graph.provider``` property is necessary when you have more than one driver in the classpath. Otherwise, it will take the first one.

These configuration settings are the default behavior. Nevertheless, there is an option to programmatically configure these settings. Create a class that implements the ```Supplier<Graph>```, then define it using the ```@Alternative``` and ```@Priority``` annotations.

[source,java]
----
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<Graph> {

    @Produces
    public Graph get() {
        Graph graph = ...; // from a provider
        return graph;
    }
}
----

You can work with several document database instances through CDI qualifier. To identify each database instance, make a `Graph` visible for CDI by putting the ```@Produces``` and the ```@Database``` annotations in the method.

[source,java]
----
@Inject
@Database(value = DatabaseType.GRAPH, provider = "databaseA")
private GraphTemplate templateA;

@Inject
@Database(value = DatabaseType.GRAPH, provider = "databaseB")
private GraphTemplate templateB;

// producers methods
@Produces
@Database(value = DatabaseType.GRAPH, provider = "databaseA")
public Graph getManagerA() {
    return manager;
}

@Produces
@Database(value = DatabaseType.GRAPH, provider = "databaseB")
public Graph getManagerB() {
    return manager;
}
----


Eclipse JNoSQL does not provide https://mvnrepository.com/artifact/org.apache.tinkerpop/gremlin-core[Apache Tinkerpop 3 dependency]; check if the provider does. Otherwise, do it manually.

[source,xml]
----
<dependency>
    <groupId>org.apache.tinkerpop</groupId>
    <artifactId>jnosql-gremlin-core</artifactId>
    <version>${tinkerpop.version}</version>
</dependency>
<dependency>
    <groupId>org.apache.tinkerpop</groupId>
    <artifactId>jnosql-gremlin-groovy</artifactId>
    <version>${tinkerpop.version}</version>
</dependency>
----

=== Jakarta Data

Eclipse JNoSQL as a Jakarta Data implementations supports the following list of predicate keywords on their repositories.


|===
|Keyword |Description | Method signature Sample

|And
|The ```and``` operator.
|findByNameAndYear

|Or
|The ```or``` operator.
|findByNameOrYear

|Between
|Find results where the property is between the given values
|findByDateBetween

|LessThan
|Find results where the property is less than the given value
|findByAgeLessThan

|GreaterThan
|Find results where the property is greater than the given value
|findByAgeGreaterThan

|LessThanEqual
|Find results where the property is less than or equal to the given value
|findByAgeLessThanEqual

|GreaterThanEqual
|Find results where the property is greater than or equal to the given value
|findByAgeGreaterThanEqual

|Like
|Finds string values "like" the given expression
|findByTitleLike

|In
|Find results where the property is one of the values that are contained within the given list
|findByIdIn

|True
|Finds results where the property has a boolean value of true.
|findBySalariedTrue

|False
|Finds results where the property has a boolean value of false.
|findByCompletedFalse

|Not
|The logical NOT negates all the previous keywords, but True or False. It needs to include as a prefix "Not" to a keyword.
|findByNameNot, findByAgeNotGreaterThan

|OrderBy
|Specify a static sorting order followed by the property path and direction of ascending.
|findByNameOrderByAge

|OrderBy____Desc
|Specify a static sorting order followed by the property path and direction of descending.
|findByNameOrderByAgeDesc

|OrderBy____Asc
|Specify a static sorting order followed by the property path and direction of ascending.
|findByNameOrderByAgeAsc

|OrderBy____(Asc\|Desc)*(Asc\|Desc)
|Specify several static sorting orders
|findByNameOrderByAgeAscNameDescYearAsc

|===

WARNING: Eclipse JNoSQL does not support `OrderBy` annotatation and the Keyset Pagination.

=== Bean Validation

Eclipse JNoSQL provide support for bean validation. It will validate before inserting/updating and constructing an entity.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.mapping</groupId>
    <artifactId>jnosql-mapping-validation</artifactId>
    <version>1.0.0-b5</version>
</dependency>
----

This requires the https://jakarta.ee/specifications/bean-validation/[Jakarta Bean Validation] specification.

[source,java]
----
@Entity
public class Car {

    @Column
    @NotNull
    @Pattern(regexp = "[A-Z]{3}-[0-9]{4}", message = "Invalid car plate")
    private String plate;

    @Column
    @NotNull
    @MonetaryMin(value = "100", message = "There is not car cheap like that")
    @MonetaryMax(value = "1000000", message = "The parking does not support fancy car")
    @CurrencyAccepted(currencies = "USD", message = "The car price must work with USD")
    @Convert(MonetaryAmountConverter.class)
    private MonetaryAmount price;

    @Column
    @NotBlank
    private String model;

    @Column
    @NotBlank
    private String color;
    ...
}
----

[source,java]
----
@Inject
Template template;
...
template.insert(new Car()); // invalid car
----

=== More Information

Check the https://www.jnosql.org/spec/[reference documentation] and https://www.jnosql.org/javadoc/[JavaDocs] to learn more.

== Code of Conduct

This project is governed by the Eclipse Foundation Code of Conduct. By participating, you are expected to uphold this code of conduct. Please report unacceptable behavior to mailto:codeofconduct@eclipse.org[codeofconduct@eclipse.org].

== Getting Help

Having trouble with Eclipse JNoSQL? We’d love to help!

Please report any bugs, concerns or questions with Eclipse JNoSQL to https://github.com/eclipse/jnosql[https://github.com/eclipse/jnosql].

== Building from Source

You don’t need to build from source to use the project, but should you be interested in doing so, you can build it using Maven and Java 11 only.

[source, Bash]
----
mvn clean install
----

== For know more

If you want to know more about both the communication and mapping layer, there are two complementary files for it each specific topic:

* link:COMMUNICATION.adoc[Communication API]
* link:MAPPING.adoc[Mapping API]
